diff -ru --no-dereference ../qemu-2.11.0/accel/kvm/kvm-all.c ./accel/kvm/kvm-all.c
--- ../qemu-2.11.0/accel/kvm/kvm-all.c	2017-12-13 19:27:20.000000000 +0200
+++ ./accel/kvm/kvm-all.c	2018-01-06 13:40:04.715140400 +0200
@@ -1831,7 +1831,11 @@
     sigaddset(&waitset, SIG_IPI);
 
     do {
+#if defined(__ANDROID__)
+    	__rt_sigtimedwait(&waitset, &siginfo, &ts, sizeof(waitset));
+#else
         r = sigtimedwait(&waitset, &siginfo, &ts);
+#endif // __ANDROID__
         if (r == -1 && !(errno == EAGAIN || errno == EINTR)) {
             perror("sigtimedwait");
             exit(1);
diff -ru --no-dereference ../qemu-2.11.0/audio/sdlaudio.c ./audio/sdlaudio.c
--- ../qemu-2.11.0/audio/sdlaudio.c	2017-12-13 19:27:20.000000000 +0200
+++ ./audio/sdlaudio.c	2017-12-25 11:28:14.654371900 +0200
@@ -66,6 +66,7 @@
 } glob_sdl;
 typedef struct SDLAudioState SDLAudioState;
 
+#ifndef __LIMBO__
 static void GCC_FMT_ATTR (1, 2) sdl_logerr (const char *fmt, ...)
 {
     va_list ap;
@@ -76,6 +77,7 @@
 
     AUD_log (AUDIO_CAP, "Reason: %s\n", SDL_GetError ());
 }
+#endif //__LIMBO__
 
 static int sdl_lock (SDLAudioState *s, const char *forfn)
 {
@@ -206,6 +208,7 @@
 {
     int status;
 #ifndef _WIN32
+#ifndef __ANDROID__
     int err;
     sigset_t new, old;
 
@@ -220,6 +223,7 @@
         dolog ("sdl_open: pthread_sigmask failed: %s\n", strerror (err));
         return -1;
     }
+#endif // __ANDROID__
 #endif
 
     status = SDL_OpenAudio (req, obt);
@@ -228,6 +232,7 @@
     }
 
 #ifndef _WIN32
+#ifndef __ANDROID__
     err = pthread_sigmask (SIG_SETMASK, &old, NULL);
     if (err) {
         dolog ("sdl_open: pthread_sigmask (restore) failed: %s\n",
@@ -236,6 +241,7 @@
            so exit the process */
         exit (EXIT_FAILURE);
     }
+#endif // __ANDROID__
 #endif
     return status;
 }
diff -ru --no-dereference ../qemu-2.11.0/block/file-posix.c ./block/file-posix.c
--- ../qemu-2.11.0/block/file-posix.c	2017-12-13 19:27:20.000000000 +0200
+++ ./block/file-posix.c	2017-12-25 11:28:14.654371900 +0200
@@ -2014,7 +2014,9 @@
     }
 
     if (nocow) {
-#ifdef __linux__
+//Limbo: Flag not supported by Android
+//#ifdef __linux__
+#if defined ( __linux__ ) & ( !defined ( __ANDROID__) | defined (__ANDROID_HAS_FS_IOC__))
         /* Set NOCOW flag to solve performance issue on fs like btrfs.
          * This is an optimisation. The FS_IOC_SETFLAGS ioctl return value
          * will be ignored since any failure of this operation should not
diff -ru --no-dereference ../qemu-2.11.0/block/qcow.c ./block/qcow.c
--- ../qemu-2.11.0/block/qcow.c	2017-12-13 19:27:20.000000000 +0200
+++ ./block/qcow.c	2017-12-25 11:28:14.669977800 +0200
@@ -299,6 +299,9 @@
         bs->backing_file[len] = '\0';
     }
 
+#ifndef __LIMBO__
+//XXX: Limbo: Disabling this limitation for now since we need it for Pausing the VM
+
     /* Disable migration when qcow images are used */
     error_setg(&s->migration_blocker, "The qcow format used by node '%s' "
                "does not support live migration",
@@ -309,6 +312,7 @@
         error_free(s->migration_blocker);
         goto fail;
     }
+#endif //__LIMBO__
 
     QDECREF(encryptopts);
     qapi_free_QCryptoBlockOpenOptions(crypto_opts);
diff -ru --no-dereference ../qemu-2.11.0/block/vvfat.c ./block/vvfat.c
--- ../qemu-2.11.0/block/vvfat.c	2017-12-13 19:27:20.000000000 +0200
+++ ./block/vvfat.c	2017-12-25 11:28:14.669977800 +0200
@@ -80,6 +80,10 @@
     unsigned int size,next,item_size;
 } array_t;
 
+#ifdef __LIMBO__
+int size_clusters = 0;
+#endif //__LIMBO__
+
 static inline void array_init(array_t* array,unsigned int item_size)
 {
     array->pointer = NULL;
@@ -1282,6 +1286,8 @@
     s->sector_count = s->offset_to_root_dir
                     + s->sectors_per_cluster * s->cluster_count;
 
+#ifndef __LIMBO__
+    //XXX: Limbo: Disabling this limitation for now since we need it for Pausing the VM
     /* Disable migration when vvfat is used rw */
     if (s->qcow) {
         error_setg(&s->migration_blocker,
@@ -1295,6 +1301,7 @@
             goto fail;
         }
     }
+#endif // __LIMBO__
 
     if (s->offset_to_bootsector > 0) {
         init_mbr(s, cyls, heads, secs);
@@ -3047,7 +3054,13 @@
 
     for (i = sector2cluster(s, sector_num);
             i <= sector2cluster(s, sector_num + nb_sectors - 1); i++)
-        if (i >= 0)
+#ifdef __LIMBO__
+		//FIXME: Limbo: For some reason the sector_num is lesser than the fake_sectors
+		// for now we add this check but we should fix this in the future
+    	if (i >= 0 && i < size_clusters)
+#else
+    	if (i >= 0)
+#endif //__LIMBO__
             s->used_clusters[i] |= USED_ALLOCATED;
 
 DLOG(checkpoint());
@@ -3144,6 +3157,12 @@
     QemuOpts *opts = NULL;
     int ret;
     int size = sector2cluster(s, s->sector_count);
+
+//Limbo:
+#ifdef __LIMBO__
+    size_clusters = size;
+#endif //__LIMBO__
+
     QDict *options;
 
     s->used_clusters = calloc(size, 1);
diff -ru --no-dereference ../qemu-2.11.0/block.c ./block.c
--- ../qemu-2.11.0/block.c	2017-12-13 19:27:20.000000000 +0200
+++ ./block.c	2017-12-25 11:28:14.701171200 +0200
@@ -55,6 +55,11 @@
 #include <windows.h>
 #endif
 
+//Limbo: define a var for the limbo dir
+#if __LIMBO__
+extern char * limbo_base_dir;
+#endif //__LIMBO__
+
 #define NOT_DONE 0x7fffffff /* used while emulated sync operation in progress */
 
 static QTAILQ_HEAD(, BlockDriverState) graph_bdrv_states =
@@ -540,7 +545,19 @@
     const char *tmpdir;
     tmpdir = getenv("TMPDIR");
     if (!tmpdir) {
+#ifdef __LIMBO__
+    	char limboTmpDir[256];
+    	if(limbo_base_dir!=NULL){
+    		strcpy(limboTmpDir, limbo_base_dir); //Get it from the -L option
+    		strcat(limboTmpDir, "/tmp");
+    		tmpdir = limboTmpDir;
+    	} else
+    		tmpdir = "/mnt/sdcard/limbo/tmp"; //else try a hardcoded path
+
+		LOGD("Setting up temp dir: %s", tmpdir);
+#else
         tmpdir = "/var/tmp";
+#endif
     }
     if (snprintf(filename, size, "%s/vl.XXXXXX", tmpdir) >= size) {
         return -EOVERFLOW;
diff -ru --no-dereference ../qemu-2.11.0/chardev/char-parallel.c ./chardev/char-parallel.c
--- ../qemu-2.11.0/chardev/char-parallel.c	2017-12-13 19:27:20.000000000 +0200
+++ ./chardev/char-parallel.c	2017-12-25 11:28:14.701171200 +0200
@@ -37,7 +37,9 @@
 #else
 #ifdef __linux__
 #include <linux/ppdev.h>
+#if !defined ( __ANDROID__ ) | defined ( __ANDROID_HAS_PARPORT__ )
 #include <linux/parport.h>
+#endif //__ANDROID__
 #endif
 #endif
 
@@ -113,6 +115,10 @@
         }
         break;
     case CHR_IOCTL_PP_EPP_READ_ADDR:
+//Limbo
+#if defined ( __ANDROID__ ) & !defined ( __ANDROID_HAS_IEEE__ )
+    	printf("%s: Mode IEEE1284_MODE_EPP|IEEE1284_ADDR not supported\n", __func__);
+#else
         if (pp_hw_mode(drv, IEEE1284_MODE_EPP | IEEE1284_ADDR)) {
             struct ParallelIOArg *parg = arg;
             int n = read(fd, parg->buffer, parg->count);
@@ -120,8 +126,13 @@
                 return -EIO;
             }
         }
+#endif
         break;
     case CHR_IOCTL_PP_EPP_READ:
+//Limbo
+#if defined ( __ANDROID__ ) & !defined ( __ANDROID_HAS_IEEE__ )
+    	printf("%s: Mode IEEE1284_MODE_EPP|IEEE1284_ADDR not supported\n", __func__);
+#else
         if (pp_hw_mode(drv, IEEE1284_MODE_EPP)) {
             struct ParallelIOArg *parg = arg;
             int n = read(fd, parg->buffer, parg->count);
@@ -129,8 +140,12 @@
                 return -EIO;
             }
         }
+#endif //__ANDROID__
         break;
     case CHR_IOCTL_PP_EPP_WRITE_ADDR:
+#if defined ( __ANDROID__ ) & !defined ( __ANDROID_HAS_IEEE__ )
+    	printf("%s: Mode IEEE1284_MODE_EPP|IEEE1284_ADDR not supported\n", __func__);
+#else
         if (pp_hw_mode(drv, IEEE1284_MODE_EPP | IEEE1284_ADDR)) {
             struct ParallelIOArg *parg = arg;
             int n = write(fd, parg->buffer, parg->count);
@@ -138,8 +153,12 @@
                 return -EIO;
             }
         }
+#endif //__ANDROID__
         break;
     case CHR_IOCTL_PP_EPP_WRITE:
+#if defined ( __ANDROID__ ) & !defined ( __ANDROID_HAS_IEEE__ )
+    	printf("%s: Mode IEEE1284_MODE_EPP|IEEE1284_ADDR not supported\n", __func__);
+#else
         if (pp_hw_mode(drv, IEEE1284_MODE_EPP)) {
             struct ParallelIOArg *parg = arg;
             int n = write(fd, parg->buffer, parg->count);
@@ -147,6 +166,7 @@
                 return -EIO;
             }
         }
+#endif //__ANDROID__
         break;
     default:
         return -ENOTSUP;
@@ -168,7 +188,11 @@
     }
 
     drv->fd = fd;
+#if defined ( __ANDROID__ ) & !defined ( __ANDROID_HAS_IEEE__ )
+    printf("%s: Mode IEEE1284_MODE_COMPAT not supported\n", __func__);
+#else
     drv->mode = IEEE1284_MODE_COMPAT;
+#endif // __ANDROID__
 }
 #endif /* __linux__ */
 
@@ -287,8 +311,11 @@
     Chardev *chr = CHARDEV(obj);
     ParallelChardev *drv = PARALLEL_CHARDEV(chr);
     int fd = drv->fd;
-
+#if defined ( __ANDROID__ ) & !defined ( __ANDROID_HAS_IEEE__ )
+    printf("%s: Mode IEEE1284_MODE_COMPAT not supported\n", __func__);
+#else
     pp_hw_mode(drv, IEEE1284_MODE_COMPAT);
+#endif // __ANDROID__
     ioctl(fd, PPRELEASE);
     close(fd);
     qemu_chr_be_event(chr, CHR_EVENT_CLOSED);
diff -ru --no-dereference ../qemu-2.11.0/configure ./configure
--- ../qemu-2.11.0/configure	2017-12-13 19:27:20.000000000 +0200
+++ ./configure	2018-01-14 15:36:32.009853400 +0200
@@ -111,6 +111,8 @@
 
 compile_object() {
   local_cflags="$1"
+  # Limbo debugging tests
+  #echo do_cc $QEMU_CFLAGS $local_cflags -c -o $TMPO $TMPC
   do_cc $QEMU_CFLAGS $local_cflags -c -o $TMPO $TMPC
 }
 
@@ -488,7 +490,10 @@
 windres="${WINDRES-${cross_prefix}windres}"
 pkg_config_exe="${PKG_CONFIG-${cross_prefix}pkg-config}"
 query_pkg_config() {
-    "${pkg_config_exe}" ${QEMU_PKG_CONFIG_FLAGS} "$@"
+    #Limbo: don't have pkg-config
+	#"${pkg_config_exe}" ${QEMU_PKG_CONFIG_FLAGS} "$@"
+	echo ""
+ 
 }
 pkg_config=query_pkg_config
 sdl_config="${SDL_CONFIG-${cross_prefix}sdl-config}"
@@ -1966,7 +1971,9 @@
 # pkg-config probe
 
 if ! has "$pkg_config_exe"; then
-  error_exit "pkg-config binary '$pkg_config_exe' not found"
+  #Limbo: don't have pkg-config
+  #error_exit "pkg-config binary '$pkg_config_exe' not found"
+  echo "Limbo: Ignoring pkg-config detection"
 fi
 
 ##########################################
@@ -2813,14 +2820,17 @@
       if compile_prog "$sdl_cflags" "$sdl_libs" ; then
 	:
       else
-        sdl=no
+        #sdl=no
+        echo "Limbo: Skipping SDL"
       fi
     fi # static link
   else # sdl not found
     if test "$sdl" = "yes" ; then
-      feature_not_found "sdl" "Install SDL devel"
+      #feature_not_found "sdl" "Install SDL devel"
+	  echo "Limbo: Skipping SDL Detection"
     fi
-    sdl=no
+    #Limbo: Let us define SDL ourselves
+    #sdl=no
   fi # sdl compile test
 fi
 
@@ -3284,7 +3294,8 @@
         LIBS="$glib_libs $LIBS"
         libs_qga="$glib_libs $libs_qga"
     else
-        error_exit "glib-$glib_req_ver $i is required to compile QEMU"
+        #error_exit "glib-$glib_req_ver $i is required to compile QEMU"
+        echo "Limbo: Skipping glib version detection"
     fi
 done
 
@@ -5125,9 +5136,12 @@
   CFLAGS="-fprofile-arcs -ftest-coverage -g $CFLAGS"
   LDFLAGS="-fprofile-arcs -ftest-coverage $LDFLAGS"
 elif test "$fortify_source" = "yes" ; then
-  CFLAGS="-O2 -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=2 $CFLAGS"
+  #Limbo: We handle optimization later
+  #CFLAGS="-O2 -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=2 $CFLAGS"
+  CFLAGS="-U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=2 $CFLAGS"
 elif test "$debug" = "no"; then
-  CFLAGS="-O2 $CFLAGS"
+  #Limbo: We handle optimization later
+  CFLAGS="$CFLAGS"
 fi
 
 ##########################################
diff -ru --no-dereference ../qemu-2.11.0/hmp.c ./hmp.c
--- ../qemu-2.11.0/hmp.c	2017-12-13 19:27:20.000000000 +0200
+++ ./hmp.c	2017-12-25 11:43:42.146757200 +0200
@@ -1879,6 +1879,97 @@
     bool is_block_migration;
 } HMPMigrationStatus;
 
+#ifdef __LIMBO__
+int migration_status = 0;
+int get_migration_status (){
+	return migration_status;
+}
+
+static void limbo_migrate_status_cb(void *opaque)
+{
+    HMPMigrationStatus *status = opaque;
+    MigrationInfo *info;
+
+    info = qmp_query_migrate(NULL);
+    if (!info->has_status || info->status == MIGRATION_STATUS_ACTIVE ||
+        info->status == MIGRATION_STATUS_SETUP) {
+        if (info->has_disk) {
+            int progress;
+
+            if (info->disk->remaining) {
+                progress = info->disk->transferred * 100 / info->disk->total;
+            } else {
+                progress = 100;
+            }
+            LOGI("Completed progress=%d", progress);
+        }else
+        	LOGI("No status info");
+        LOGI("timer_mod\n");
+        timer_mod(status->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + 1000);
+    } else {
+        if (status->is_block_migration) {
+           LOGI("End");
+        }
+        if (info->has_error_desc) {
+            error_report("%s", info->error_desc);
+        }
+        timer_del(status->timer);
+        g_free(status);
+       LOGI("Migration DONE");
+        migration_status = 2;
+    }
+
+    qapi_free_MigrationInfo(info);
+
+}
+int limbo_migrate(const char * uri, char * error)
+{
+    bool detach = 0;
+    bool blk = 0;
+    bool inc = 0;
+    Error *err = NULL;
+
+    LOGI("Starting migration: %s", uri);
+    if(migration_status == 1){
+    	LOGE("Another migration is in progress");
+    	return -1;
+    }
+
+    migration_status = 1;
+
+    LOGI("Stopping VM");
+    //Stop the VM
+    qmp_stop(NULL);
+
+    LOGI("Starting QMP migration");
+    //Migrate
+    qmp_migrate(uri, !!blk, blk, !!inc, inc, false, false, &err);
+    if (err) {
+    	strcpy(error,error_get_pretty(err));
+    	LOGE("migrate: %s\n", error_get_pretty(err));
+        error_report_err(err);
+        migration_status = -1;
+        qmp_cont(NULL);
+        return -1;
+    }
+
+    LOGI("Checking detach");
+    //Set status cb
+    if (!detach) {
+    	LOGI("Migration is detached starting status and timer");
+        HMPMigrationStatus *status;
+        status = g_malloc0(sizeof(*status));
+        status->is_block_migration = blk || inc;
+       status->timer = timer_new_ms(QEMU_CLOCK_REALTIME, limbo_migrate_status_cb,
+                                          status);
+        timer_mod(status->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME));
+    }
+   LOGI("Migration end");
+   return 0;
+}
+#endif //__LIMBO__
+
+
 static void hmp_migrate_status_cb(void *opaque)
 {
     HMPMigrationStatus *status = opaque;
@@ -1911,6 +2002,12 @@
         monitor_resume(status->mon);
         timer_del(status->timer);
         g_free(status);
+
+#ifdef __LIMBO__
+        LOGI("Migration DONE");
+        migration_status = 2;
+#endif //__LIMBO__
+
     }
 
     qapi_free_MigrationInfo(info);
@@ -1924,9 +2021,16 @@
     const char *uri = qdict_get_str(qdict, "uri");
     Error *err = NULL;
 
+#ifdef __LIMBO__
+    migration_status = 1;
+#endif //__LIMBO__
+
     qmp_migrate(uri, !!blk, blk, !!inc, inc, false, false, &err);
     if (err) {
         hmp_handle_error(mon, &err);
+#ifdef __LIMBO__
+        migration_status = -1;
+#endif //__LIMBO__
         return;
     }
 
diff -ru --no-dereference ../qemu-2.11.0/hw/core/loader.c ./hw/core/loader.c
--- ../qemu-2.11.0/hw/core/loader.c	2017-12-13 19:27:20.000000000 +0200
+++ ./hw/core/loader.c	2017-12-25 11:28:14.758260600 +0200
@@ -64,6 +64,11 @@
 int get_image_size(const char *filename)
 {
     int fd, size;
+#ifdef __LIMBO__
+	if (strncmp(filename, "/content/", 9) == 0)
+		fd = android_open(filename, O_RDONLY | O_BINARY);
+	else
+#endif //__LIMBO__
     fd = open(filename, O_RDONLY | O_BINARY);
     if (fd < 0)
         return -1;
@@ -77,6 +82,11 @@
 int load_image(const char *filename, uint8_t *addr)
 {
     int fd, size;
+#ifdef __LIMBO__
+	if (strncmp(filename, "/content/", 9) == 0) {
+		fd = android_open(filename, O_RDONLY | O_BINARY);
+	} else
+#endif //__LIMBO__
     fd = open(filename, O_RDONLY | O_BINARY);
     if (fd < 0)
         return -1;
@@ -103,6 +113,11 @@
     int fd;
     ssize_t actsize;
 
+#ifdef __LIMBO__
+	if (strncmp(filename, "/content/", 9) == 0)
+		fd = android_open(filename, O_RDONLY | O_BINARY);
+	else
+#endif //__LIMBO__
     fd = open(filename, O_RDONLY | O_BINARY);
     if (fd < 0) {
         return -1;
@@ -249,6 +264,11 @@
     struct exec e;
     uint32_t magic;
 
+#ifdef __LIMBO__
+	if (strncmp(filename, "/content/", 9) == 0)
+		fd = android_open(filename, O_RDONLY | O_BINARY);
+	else
+#endif //__LIMBO__
     fd = open(filename, O_RDONLY | O_BINARY);
     if (fd < 0)
         return -1;
@@ -377,6 +397,11 @@
     }
     e_ident = hdr;
 
+#ifdef __LIMBO__
+    if (strncmp(filename, "/content/", 9) == 0)
+    	fd = android_open(filename, O_RDONLY | O_BINARY);
+    else
+#endif //__LIMBO__
     fd = open(filename, O_RDONLY | O_BINARY);
     if (fd < 0) {
         error_setg_errno(errp, errno, "Failed to open file: %s", filename);
@@ -453,6 +478,11 @@
     int fd, data_order, target_data_order, must_swab, ret = ELF_LOAD_FAILED;
     uint8_t e_ident[EI_NIDENT];
 
+#ifdef __LIMBO__
+	if (strncmp(filename, "/content/", 9) == 0)
+		fd = android_open(filename, O_RDONLY | O_BINARY);
+	else
+#endif // __LIMBO__
     fd = open(filename, O_RDONLY | O_BINARY);
     if (fd < 0) {
         perror(filename);
@@ -608,6 +638,11 @@
     int ret = -1;
     int do_uncompress = 0;
 
+#ifdef __LIMBO__
+	if (strncmp(filename, "/content/", 9) == 0)
+		fd = android_open(filename, O_RDONLY | O_BINARY);
+	else
+#endif //__LIMBO__
     fd = open(filename, O_RDONLY | O_BINARY);
     if (fd < 0)
         return -1;
@@ -907,6 +942,11 @@
         rom->path = g_strdup(file);
     }
 
+#ifdef __LIMBO__
+	if (strncmp(rom->path, "/content/", 9) == 0)
+		fd = android_open(rom->path, O_RDONLY | O_BINARY);
+	else
+#endif //__LIMBO__
     fd = open(rom->path, O_RDONLY | O_BINARY);
     if (fd == -1) {
         fprintf(stderr, "Could not open option rom '%s': %s\n",
diff -ru --no-dereference ../qemu-2.11.0/hw/usb/dev-mtp.c ./hw/usb/dev-mtp.c
--- ../qemu-2.11.0/hw/usb/dev-mtp.c	2017-12-13 19:27:20.000000000 +0200
+++ ./hw/usb/dev-mtp.c	2017-12-25 11:28:14.770275400 +0200
@@ -14,7 +14,9 @@
 #include <wchar.h>
 #include <dirent.h>
 
+#if !defined ( __ANDROID__ ) | defined ( __ANDROID_HAS_STATVFS__ )
 #include <sys/statvfs.h>
+#endif // __ANDROID__
 #ifdef CONFIG_INOTIFY1
 #include <sys/inotify.h>
 #include "qemu/main-loop.h"
@@ -847,6 +849,7 @@
 static MTPData *usb_mtp_get_storage_info(MTPState *s, MTPControl *c)
 {
     MTPData *d = usb_mtp_data_alloc(c);
+#if !defined ( __ANDROID__ ) | defined ( __ANDROID_HAS_STATVFS__ )
     struct statvfs buf;
     int rc;
 
@@ -875,6 +878,8 @@
 
     usb_mtp_add_str(d, s->desc);
     usb_mtp_add_wstr(d, L"123456789abcdef");
+
+#endif //__ANDROID__
     return d;
 }
 
diff -ru --no-dereference ../qemu-2.11.0/hw/usb/hcd-ohci.c ./hw/usb/hcd-ohci.c
--- ../qemu-2.11.0/hw/usb/hcd-ohci.c	2017-12-13 19:27:20.000000000 +0200
+++ ./hw/usb/hcd-ohci.c	2017-12-25 11:28:14.785913300 +0200
@@ -935,7 +935,7 @@
     }
     return 1;
 }
-
+/* Limbo: no trace
 static void ohci_td_pkt(const char *msg, const uint8_t *buf, size_t len)
 {
     bool print16;
@@ -969,6 +969,10 @@
         p += sprintf(p, " %.2x", buf[i]);
     }
 }
+*/
+static void ohci_td_pkt(const char *msg, const uint8_t *buf, size_t len)
+ {
+ }
 
 /* Service a transport descriptor.
    Returns nonzero to terminate processing of this endpoint.  */
diff -ru --no-dereference ../qemu-2.11.0/include/glib-compat.h ./include/glib-compat.h
--- ../qemu-2.11.0/include/glib-compat.h	2017-12-13 19:27:20.000000000 +0200
+++ ./include/glib-compat.h	2017-12-25 11:28:14.817164300 +0200
@@ -19,9 +19,11 @@
 #include <glib.h>
 
 /* GLIB version compatibility flags */
+/* Limbo: Already Defined
 #if !GLIB_CHECK_VERSION(2, 26, 0)
 #define G_TIME_SPAN_SECOND              (G_GINT64_CONSTANT(1000000))
 #endif
+*/
 
 #if !GLIB_CHECK_VERSION(2, 28, 0)
 static inline gint64 qemu_g_get_monotonic_time(void)
@@ -56,9 +58,12 @@
 {
     gchar *path = g_build_filename(g_get_tmp_dir(), tmpl ?: ".XXXXXX", NULL);
 
+#ifndef __ANDROID__
     if (mkdtemp(path) != NULL) {
         return path;
     }
+#endif //__ANDROID__
+
     /* Error occurred, clean up. */
     g_set_error(error, G_FILE_ERROR, g_file_error_from_errno(errno),
                 "mkdtemp() failed");
@@ -312,16 +317,17 @@
 }
 #endif
 
-#if !GLIB_CHECK_VERSION(2, 26, 0)
-static inline void g_source_set_name(GSource *source, const char *name)
-{
-    /* This is just a debugging aid, so leaving it a no-op */
-}
-static inline void g_source_set_name_by_id(guint tag, const char *name)
-{
-    /* This is just a debugging aid, so leaving it a no-op */
-}
-#endif
+/* Limbo: already defined */
+//#if !GLIB_CHECK_VERSION(2, 26, 0)
+//static inline void g_source_set_name(GSource *source, const char *name)
+//{
+//    /* This is just a debugging aid, so leaving it a no-op */
+//}
+//static inline void g_source_set_name_by_id(guint tag, const char *name)
+//{
+//    /* This is just a debugging aid, so leaving it a no-op */
+//}
+//#endif
 
 #if !GLIB_CHECK_VERSION(2, 36, 0)
 /* Always fail.  This will not include error_report output in the test log,
@@ -330,9 +336,11 @@
 #define g_test_initialized() (0)
 #endif
 #if !GLIB_CHECK_VERSION(2, 38, 0)
+/* Limbo: don't need this
 #ifdef CONFIG_HAS_GLIB_SUBPROCESS_TESTS
 #error schizophrenic detection of glib subprocess testing
 #endif
+*/
 #define g_test_subprocess() (0)
 #endif
 
@@ -344,15 +352,16 @@
                           gpointer fn,
                           gpointer data_free_func)
 {
-#if GLIB_CHECK_VERSION(2, 26, 0)
+//Limbo: don't need this check for newer glib
+//#if GLIB_CHECK_VERSION(2, 26, 0)
     /* back-compat casts, remove this once we can require new-enough glib */
     g_test_add_vtable(path, 0, data, NULL,
                       (GTestFixtureFunc)fn, (GTestFixtureFunc) data_free_func);
-#else
-    /* back-compat casts, remove this once we can require new-enough glib */
-    g_test_add_vtable(path, 0, data, NULL,
-                      (void (*)(void)) fn, (void (*)(void)) data_free_func);
-#endif
+//#else
+//    /* back-compat casts, remove this once we can require new-enough glib */
+//    g_test_add_vtable(path, 0, data, NULL,
+//                      (void (*)(void)) fn, (void (*)(void)) data_free_func);
+//#endif
 }
 #endif
 
diff -ru --no-dereference ../qemu-2.11.0/include/qemu/error-report.h ./include/qemu/error-report.h
--- ../qemu-2.11.0/include/qemu/error-report.h	2017-12-13 19:27:20.000000000 +0200
+++ ./include/qemu/error-report.h	2017-12-25 11:28:14.832788400 +0200
@@ -30,12 +30,15 @@
 void loc_set_cmdline(char **argv, int idx, int cnt);
 void loc_set_file(const char *fname, int lno);
 
+#if !defined (__LIMBO__)
 void error_vprintf(const char *fmt, va_list ap) GCC_FMT_ATTR(1, 0);
 void error_printf(const char *fmt, ...) GCC_FMT_ATTR(1, 2);
 void error_vprintf_unless_qmp(const char *fmt, va_list ap) GCC_FMT_ATTR(1, 0);
 void error_printf_unless_qmp(const char *fmt, ...) GCC_FMT_ATTR(1, 2);
+#endif //__LIMBO__
 void error_set_progname(const char *argv0);
 
+#if !defined (__LIMBO__)
 void error_vreport(const char *fmt, va_list ap) GCC_FMT_ATTR(1, 0);
 void warn_vreport(const char *fmt, va_list ap) GCC_FMT_ATTR(1, 0);
 void info_vreport(const char *fmt, va_list ap) GCC_FMT_ATTR(1, 0);
@@ -43,6 +46,7 @@
 void error_report(const char *fmt, ...) GCC_FMT_ATTR(1, 2);
 void warn_report(const char *fmt, ...) GCC_FMT_ATTR(1, 2);
 void info_report(const char *fmt, ...) GCC_FMT_ATTR(1, 2);
+#endif //__LIMBO__
 
 const char *error_get_progname(void);
 extern bool enable_timestamp_msg;
diff -ru --no-dereference ../qemu-2.11.0/include/ui/console.h ./include/ui/console.h
--- ../qemu-2.11.0/include/ui/console.h	2017-12-13 19:27:20.000000000 +0200
+++ ./include/ui/console.h	2017-12-25 11:28:14.845352800 +0200
@@ -29,8 +29,14 @@
 #define QEMU_CAPS_LOCK_LED   (1 << 2)
 
 /* in ms */
+#ifdef __LIMBO__
+//LIMBO: we can override the refresh rate for SDL here
 #define GUI_REFRESH_INTERVAL_DEFAULT    30
 #define GUI_REFRESH_INTERVAL_IDLE     3000
+#else
+#define GUI_REFRESH_INTERVAL_DEFAULT    30
+#define GUI_REFRESH_INTERVAL_IDLE     3000
+#endif
 
 /* Color number is match to standard vga palette */
 enum qemu_color_names {
diff -ru --no-dereference ../qemu-2.11.0/Makefile ./Makefile
--- ../qemu-2.11.0/Makefile	2017-12-13 19:27:20.000000000 +0200
+++ ./Makefile	2018-01-05 03:24:46.157560600 +0200
@@ -46,13 +46,13 @@
 
 # Check that we're not trying to do an out-of-tree build from
 # a tree that's been used for an in-tree build.
-ifneq ($(realpath $(SRC_PATH)),$(realpath .))
-ifneq ($(wildcard $(SRC_PATH)/config-host.mak),)
-$(error This is an out of tree build but your source tree ($(SRC_PATH)) \
+#ifneq ($(realpath $(SRC_PATH)),$(realpath .))
+#ifneq ($(wildcard $(SRC_PATH)/config-host.mak),)
+#$(error This is an out of tree build but your source tree ($(SRC_PATH)) \
 seems to have been used for an in-tree build. You can fix this by running \
 "make distclean && rm -rf *-linux-user *-softmmu" in your source tree)
-endif
-endif
+#endif
+#endif
 
 CONFIG_SOFTMMU := $(if $(filter %-softmmu,$(TARGET_DIRS)),y)
 CONFIG_USER_ONLY := $(if $(filter %-user,$(TARGET_DIRS)),y)
@@ -259,7 +259,7 @@
 
 LIBS+=-lz $(LIBS_TOOLS)
 
-HELPERS-$(CONFIG_LINUX) = qemu-bridge-helper$(EXESUF)
+#HELPERS-$(CONFIG_LINUX) = qemu-bridge-helper$(EXESUF)
 
 ifdef BUILD_DOCS
 DOCS=qemu-doc.html qemu-doc.txt qemu.1 qemu-img.1 qemu-nbd.8 qemu-ga.8
@@ -338,9 +338,10 @@
                 common-obj-m \
                 trace-obj-y)
 
-include $(SRC_PATH)/tests/Makefile.include
+#include $(SRC_PATH)/tests/Makefile.include
 
-all: $(DOCS) $(TOOLS) $(HELPERS-y) recurse-all modules
+#all: $(DOCS) $(TOOLS) $(HELPERS-y) recurse-all modules
+all: $(HELPERS-y) recurse-all modules
 
 qemu-version.h: FORCE
 	$(call quiet-command, \
@@ -417,7 +418,8 @@
 
 ALL_SUBDIRS=$(TARGET_DIRS) $(patsubst %,pc-bios/%, $(ROMS))
 
-recurse-all: $(SUBDIR_RULES) $(ROMSUBDIR_RULES)
+#Limbo: no optional roms
+recurse-all: $(SUBDIR_RULES) #$(ROMSUBDIR_RULES)
 
 $(BUILD_DIR)/version.o: $(SRC_PATH)/version.rc config-host.h
 	$(call quiet-command,$(WINDRES) -I$(BUILD_DIR) -o $@ $<,"RC","version.o")
@@ -434,13 +436,13 @@
 
 COMMON_LDADDS = libqemuutil.a
 
-qemu-img.o: qemu-img-cmds.h
+#qemu-img.o: qemu-img-cmds.h
 
-qemu-img$(EXESUF): qemu-img.o $(block-obj-y) $(crypto-obj-y) $(io-obj-y) $(qom-obj-y) $(COMMON_LDADDS)
-qemu-nbd$(EXESUF): qemu-nbd.o $(block-obj-y) $(crypto-obj-y) $(io-obj-y) $(qom-obj-y) $(COMMON_LDADDS)
-qemu-io$(EXESUF): qemu-io.o $(block-obj-y) $(crypto-obj-y) $(io-obj-y) $(qom-obj-y) $(COMMON_LDADDS)
+#qemu-img$(EXESUF): qemu-img.o $(block-obj-y) $(crypto-obj-y) $(io-obj-y) $(qom-obj-y) $(COMMON_LDADDS)
+#qemu-nbd$(EXESUF): qemu-nbd.o $(block-obj-y) $(crypto-obj-y) $(io-obj-y) $(qom-obj-y) $(COMMON_LDADDS)
+#qemu-io$(EXESUF): qemu-io.o $(block-obj-y) $(crypto-obj-y) $(io-obj-y) $(qom-obj-y) $(COMMON_LDADDS)
 
-qemu-bridge-helper$(EXESUF): qemu-bridge-helper.o $(COMMON_LDADDS)
+#qemu-bridge-helper$(EXESUF): qemu-bridge-helper.o $(COMMON_LDADDS)
 
 qemu-keymap$(EXESUF): qemu-keymap.o ui/input-keymap.o $(COMMON_LDADDS)
 
@@ -892,7 +894,7 @@
 
 # Include automatically generated dependency files
 # Dependencies in Makefile.objs files come from our recursive subdir rules
--include $(wildcard *.d tests/*.d)
+#-include $(wildcard *.d tests/*.d)
 
 include $(SRC_PATH)/tests/docker/Makefile.include
 include $(SRC_PATH)/tests/vm/Makefile.include
diff -ru --no-dereference ../qemu-2.11.0/Makefile.target ./Makefile.target
--- ../qemu-2.11.0/Makefile.target	2017-12-13 19:27:20.000000000 +0200
+++ ./Makefile.target	2018-01-05 12:19:49.176109000 +0200
@@ -1,5 +1,7 @@
 # -*- Mode: makefile -*-
 
+include $(LIMBO_JNI_ROOT)/android-config.mak
+
 BUILD_DIR?=$(CURDIR)/..
 
 include ../config-host.mak
@@ -188,13 +190,15 @@
 
 COMMON_LDADDS = ../libqemuutil.a
 
+#Limbo: Don't build an executable but a lib
 # build either PROG or PROGW
-$(QEMU_PROG_BUILD): $(all-obj-y) $(COMMON_LDADDS)
-	$(call LINK, $(filter-out %.mak, $^))
-ifdef CONFIG_DARWIN
-	$(call quiet-command,Rez -append $(SRC_PATH)/pc-bios/qemu.rsrc -o $@,"REZ","$(TARGET_DIR)$@")
-	$(call quiet-command,SetFile -a C $@,"SETFILE","$(TARGET_DIR)$@")
-endif
+#$(QEMU_PROG_BUILD): $(all-obj-y) $(COMMON_LDADDS)
+#	$(call LINK, $(filter-out %.mak, $^))
+#ifdef CONFIG_DARWIN
+#	$(call quiet-command,Rez -append $(SRC_PATH)/pc-bios/qemu.rsrc -o $@,"REZ","$(TARGET_DIR)$@")
+#	$(call quiet-command,SetFile -a C $@,"SETFILE","$(TARGET_DIR)$@")
+#endif
+include ../../android-qemu-build.mak
 
 gdbstub-xml.c: $(TARGET_XML_FILES) $(SRC_PATH)/scripts/feature_to_c.sh
 	$(call quiet-command,rm -f $@ && $(SHELL) $(SRC_PATH)/scripts/feature_to_c.sh $@ $(TARGET_XML_FILES),"GEN","$(TARGET_DIR)$@")
diff -ru --no-dereference ../qemu-2.11.0/migration/savevm.c ./migration/savevm.c
--- ../qemu-2.11.0/migration/savevm.c	2017-12-13 19:27:20.000000000 +0200
+++ ./migration/savevm.c	2017-12-25 11:28:14.873522700 +0200
@@ -62,6 +62,10 @@
 
 const unsigned int postcopy_ram_discard_version = 0;
 
+#ifdef __LIMBO__
+extern int migration_status;
+#endif //__LIMBO__
+
 /* Subcommands for QEMU_VM_COMMAND */
 enum qemu_vm_cmd {
     MIG_CMD_INVALID = 0,   /* Must be 0 */
@@ -1105,6 +1109,11 @@
 
     qemu_put_byte(f, QEMU_VM_EOF);
     qemu_fflush(f);
+
+#ifdef __LIMBO__
+    LOGI("Migration complete");
+	migration_status = 2;
+#endif
 }
 
 int qemu_savevm_state_complete_precopy(QEMUFile *f, bool iterable_only,
@@ -1210,6 +1219,12 @@
     qjson_destroy(vmdesc);
 
     qemu_fflush(f);
+
+#ifdef __LIMBO__
+    LOGI("Migration complete");
+    migration_status = 2;
+#endif
+
     return 0;
 }
 
@@ -2129,6 +2144,23 @@
     return ret;
 }
 
+//LIMBO: Snapshots are deprecated thought this might be useful
+#ifdef __LIMBO__
+int saving_state = 0;
+
+int get_save_state(){
+	return saving_state;
+}
+#endif // __LIMBO__
+
+#ifdef __LIMBO__
+//FIXME: this function currently is running via a JNI thread and cannot resume the vm right after
+void limbo_savevm(const char * limbo_snapshot_name){
+	Error *err = NULL;
+	save_snapshot(limbo_snapshot_name, err);
+}
+#endif //__LIMBO__
+
 int save_snapshot(const char *name, Error **errp)
 {
     BlockDriverState *bs, *bs1;
@@ -2239,6 +2271,11 @@
     if (saved_vm_running) {
         vm_start();
     }
+
+#ifdef __LIMBO__
+    saving_state = 0;
+#endif //__LIMBO__
+
     return ret;
 }
 
diff -ru --no-dereference ../qemu-2.11.0/monitor.c ./monitor.c
--- ../qemu-2.11.0/monitor.c	2017-12-13 19:27:20.000000000 +0200
+++ ./monitor.c	2017-12-25 11:28:14.889146800 +0200
@@ -1963,6 +1963,13 @@
 {
     mon_fd_t *monfd;
 
+#ifdef __LIMBO__
+    //LIMBO: We treat the fdname send by VNC as an actual fd
+    int fd_tmp = atoi(fdname);
+    if(fd_tmp  > 0)
+    	return fd_tmp;
+#endif //__LIMBO__
+
     QLIST_FOREACH(monfd, &mon->fds, next) {
         int fd;
 
@@ -4049,6 +4056,7 @@
     monitor_flush(opaque);
 }
 
+#ifndef __ANDROID__
 /*
  * Print to current monitor if we have one, else to stderr.
  * TODO should return int, so callers can calculate width, but that
@@ -4071,6 +4079,7 @@
         vfprintf(stderr, fmt, ap);
     }
 }
+#endif //__ANDROID__
 
 static void __attribute__((constructor)) monitor_lock_init(void)
 {
diff -ru --no-dereference ../qemu-2.11.0/os-posix.c ./os-posix.c
--- ../qemu-2.11.0/os-posix.c	2017-12-13 19:27:20.000000000 +0200
+++ ./os-posix.c	2017-12-25 11:28:14.904771300 +0200
@@ -305,6 +305,7 @@
     if (fd == -1) {
         return -1;
     }
+#ifndef __ANDROID__
     if (lockf(fd, F_TLOCK, 0) == -1) {
         close(fd);
         return -1;
@@ -314,6 +315,7 @@
         close(fd);
         return -1;
     }
+#endif // __ANDROID__
 
     /* keep pidfile open & locked forever */
     return 0;
diff -ru --no-dereference ../qemu-2.11.0/rules.mak ./rules.mak
--- ../qemu-2.11.0/rules.mak	2017-12-13 19:27:20.000000000 +0200
+++ ./rules.mak	2017-12-25 11:28:14.904771300 +0200
@@ -62,10 +62,21 @@
                   $(foreach o,$(filter %.mo,$1),$($o-objs)) \
                   $(filter-out %.o %.mo,$1))
 
+#Limbo: replace with windows path for NDK
+#%.o: %.c
+#	$(call quiet-command,$(CC) $(QEMU_LOCAL_INCLUDES) $(QEMU_INCLUDES) \
+#	     $(QEMU_CFLAGS) $(QEMU_DGFLAGS) $(CFLAGS) $($@-cflags) \
+#		 -c -o $@ $<,"CC","$(TARGET_DIR)$@")
 %.o: %.c
-	$(call quiet-command,$(CC) $(QEMU_LOCAL_INCLUDES) $(QEMU_INCLUDES) \
-	       $(QEMU_CFLAGS) $(QEMU_DGFLAGS) $(CFLAGS) $($@-cflags) \
-	       -c -o $@ $<,"CC","$(TARGET_DIR)$@")
+	$(call quiet-command,$(CC) \
+	$(subst /cygdrive/c,c:,$(QEMU_LOCAL_INCLUDES)) \
+	$(subst /cygdrive/c,c:,$(QEMU_INCLUDES)) \
+	$(subst /cygdrive/c,c:,$(QEMU_CFLAGS)) \
+	$(subst /cygdrive/c,c:,$(QEMU_DGFLAGS)) \
+	$(subst /cygdrive/c,c:,$(CFLAGS)) \
+	$(subst /cygdrive/c,c:,$($@-cflags)) \
+	-c -o $@ $(subst /cygdrive/c,c:,$<),"CC","$(TARGET_DIR)$@")
+	       	
 %.o: %.rc
 	$(call quiet-command,$(WINDRES) -I. -o $@ $<,"RC","$(TARGET_DIR)$@")
 
@@ -82,10 +93,22 @@
 	       $(QEMU_CFLAGS) $(QEMU_DGFLAGS) $(CFLAGS) \
 	       -c -o $@ $<,"CCAS","$(TARGET_DIR)$@")
 
+#Limbo: replace with windows path for NDK
+#%.o: %.cc
+#	$(call quiet-command,$(CXX) $(QEMU_LOCAL_INCLUDES) $(QEMU_INCLUDES) \
+#	       $(QEMU_CXXFLAGS) $(QEMU_DGFLAGS) $(CFLAGS) $($@-cflags) \
+#	       -c -o $@ $<,"CXX","$(TARGET_DIR)$@")
 %.o: %.cc
-	$(call quiet-command,$(CXX) $(QEMU_LOCAL_INCLUDES) $(QEMU_INCLUDES) \
-	       $(QEMU_CXXFLAGS) $(QEMU_DGFLAGS) $(CFLAGS) $($@-cflags) \
-	       -c -o $@ $<,"CXX","$(TARGET_DIR)$@")
+	$(call quiet-command,$(CXX) \
+	$(subst /cygdrive/c,c:,$(QEMU_LOCAL_INCLUDES)) \
+	$(subst /cygdrive/c,c:,$(QEMU_INCLUDES)) \
+	$(subst /cygdrive/c,c:,$(QEMU_CXXFLAGS)) \
+	$(subst /cygdrive/c,c:,$(QEMU_DGFLAGS)) \
+	$(subst /cygdrive/c,c:,$(CFLAGS)) \
+	-fpermissive \
+	$(subst /cygdrive/c,c:,$($@-cflags)) \
+	-c -o $@ $(subst /cygdrive/c,c:,$<),"CXX","$(TARGET_DIR)$@")
+	
 
 %.o: %.cpp
 	$(call quiet-command,$(CXX) $(QEMU_LOCAL_INCLUDES) $(QEMU_INCLUDES) \
@@ -301,19 +324,19 @@
 # Unnest through a faked source directory structure:
 #
 #     SRC_PATH
-#        ├── water
-#        │   └── Makefile.objs──────────────────┐
-#        │       │ hot += steam.o               │
-#        │       │ cold += ice.mo               │
-#        │       │ ice.mo-libs := -licemaker    │
-#        │       │ ice.mo-objs := ice1.o ice2.o │
-#        │       └──────────────────────────────┘
-#        │
-#        └── season
-#            └── Makefile.objs──────┐
-#                │ hot += summer.o  │
-#                │ cold += winter.o │
-#                └──────────────────┘
+#        â”œâ”€â”€ water
+#        â”‚   â””â”€â”€ Makefile.objsâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”�
+#        â”‚       â”‚ hot += steam.o               â”‚
+#        â”‚       â”‚ cold += ice.mo               â”‚
+#        â”‚       â”‚ ice.mo-libs := -licemaker    â”‚
+#        â”‚       â”‚ ice.mo-objs := ice1.o ice2.o â”‚
+#        â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
+#        â”‚
+#        â””â”€â”€ season
+#            â””â”€â”€ Makefile.objsâ”€â”€â”€â”€â”€â”€â”�
+#                â”‚ hot += summer.o  â”‚
+#                â”‚ cold += winter.o â”‚
+#                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
 #
 # In the end, the result will be:
 #
diff -ru --no-dereference ../qemu-2.11.0/scsi/qemu-pr-helper.c ./scsi/qemu-pr-helper.c
--- ../qemu-2.11.0/scsi/qemu-pr-helper.c	2017-12-13 19:27:20.000000000 +0200
+++ ./scsi/qemu-pr-helper.c	2017-12-25 12:53:36.264093300 +0200
@@ -116,6 +116,7 @@
     int pidfd;
     char pidstr[32];
 
+#ifndef __ANDROID__
     pidfd = qemu_open(pidfile, O_CREAT|O_WRONLY, S_IRUSR|S_IWUSR);
     if (pidfd == -1) {
         error_report("Cannot open pid file, %s", strerror(errno));
@@ -136,6 +137,7 @@
         error_report("Failed to write pid file");
         goto fail;
     }
+#endif
     return;
 
 fail:
diff -ru --no-dereference ../qemu-2.11.0/slirp/misc.c ./slirp/misc.c
--- ../qemu-2.11.0/slirp/misc.c	2017-12-13 19:27:20.000000000 +0200
+++ ./slirp/misc.c	2017-12-25 11:28:14.904771300 +0200
@@ -146,8 +146,12 @@
 		dup2(s, 0);
 		dup2(s, 1);
 		dup2(s, 2);
+
+//Limbo: Function missing from Android NDK
+#ifndef __NDK11_FUNC_MISSING__
 		for (s = getdtablesize() - 1; s >= 3; s--)
 		   close(s);
+#endif //__NDK11_FUNC_MISSING__
 
 		i = 0;
 		bptr = g_strdup(ex); /* No need to free() this */
diff -ru --no-dereference ../qemu-2.11.0/slirp/slirp.c ./slirp/slirp.c
--- ../qemu-2.11.0/slirp/slirp.c	2017-12-13 19:27:20.000000000 +0200
+++ ./slirp/slirp.c	2017-12-25 11:28:14.920406000 +0200
@@ -64,6 +64,10 @@
 /* for the aging of certain requests like DNS */
 #define TIMEOUT_DEFAULT 1000  /* milliseconds */
 
+#ifdef __LIMBO__
+extern char * limbo_base_dir;
+#endif
+
 #ifdef _WIN32
 
 int get_dns_addr(struct in_addr *pdns_addr)
@@ -133,8 +137,22 @@
         return 0;
     }
     old_stat = *cached_stat;
+
+//Limbo: using conf file
+#ifdef __ANDROID__
+	char limbo_resolv_file[256];
+	if(limbo_base_dir != NULL) {
+		strcpy(limbo_resolv_file, limbo_base_dir);
+	} else
+	strcpy(limbo_resolv_file, "/mnt/sdcard/limbo");
+	strcat(limbo_resolv_file, "/etc/resolv.conf");
+	LOGD("Checking cached DNS file: %s", limbo_resolv_file);
+	if (stat(limbo_resolv_file, cached_stat) != 0) {
+		LOGE("Could not check DNS file: %s", limbo_resolv_file);
+#else
     if (stat("/etc/resolv.conf", cached_stat) != 0) {
-        return -1;
+#endif // __ANDROID__
+    	return -1;
     }
     if (cached_stat->st_dev == old_stat.st_dev
         && cached_stat->st_ino == old_stat.st_ino
@@ -157,7 +175,22 @@
     void *tmp_addr = alloca(addrlen);
     unsigned if_index;
 
+//Limbo: using conf file
+#ifdef __ANDROID__
+	char limbo_resolv_file [256];
+	if(limbo_base_dir != NULL) {
+		strcpy(limbo_resolv_file, limbo_base_dir);
+	} else
+	strcpy(limbo_resolv_file, "/mnt/sdcard/limbo/");
+
+	strcat(limbo_resolv_file, "/etc/resolv.conf");
+	LOGD("Checking DNS file: %s", limbo_resolv_file);
+	f = fopen(limbo_resolv_file, "r");
+	if(!f)
+	LOGE("Could not open DNS file: %s", limbo_resolv_file);
+#else
     f = fopen("/etc/resolv.conf", "r");
+#endif //__ANDROID__
     if (!f)
         return -1;
 
diff -ru --no-dereference ../qemu-2.11.0/stubs/error-printf.c ./stubs/error-printf.c
--- ../qemu-2.11.0/stubs/error-printf.c	2017-12-13 19:27:20.000000000 +0200
+++ ./stubs/error-printf.c	2017-12-25 11:28:14.920406000 +0200
@@ -2,6 +2,7 @@
 #include "qemu-common.h"
 #include "qemu/error-report.h"
 
+#if !defined (__LIMBO__)
 void error_vprintf(const char *fmt, va_list ap)
 {
     if (g_test_initialized() && !g_test_subprocess()) {
@@ -17,3 +18,4 @@
 {
     error_vprintf(fmt, ap);
 }
+#endif //__LIMBO__
diff -ru --no-dereference ../qemu-2.11.0/ui/sdl2.c ./ui/sdl2.c
--- ../qemu-2.11.0/ui/sdl2.c	2017-12-13 19:27:20.000000000 +0200
+++ ./ui/sdl2.c	2017-12-25 11:28:14.936023000 +0200
@@ -90,10 +90,17 @@
                                          surface_width(scon->surface),
                                          surface_height(scon->surface),
                                          flags);
+#if defined(__LIMBO_SDL_FORCE_SOFTWARE_RENDERING__)
+    //LIMBO: Need to force SOFTWARE rendering because some devices don't like it
+    scon->real_renderer = SDL_CreateRenderer(scon->real_window, -1, SDL_RENDERER_SOFTWARE);
+#elif defined(__LIMBO_SDL_FORCE_HARDWARE_RENDERING__)
+    scon->real_renderer = SDL_CreateRenderer(scon->real_window, -1, SDL_RENDERER_ACCELERATED);
+#else
     scon->real_renderer = SDL_CreateRenderer(scon->real_window, -1, 0);
     if (scon->opengl) {
-        scon->winctx = SDL_GL_GetCurrentContext();
+            scon->winctx = SDL_GL_GetCurrentContext();
     }
+#endif //__LIMBO_SDL_FORCE_SOFTWARE_RENDERING__
     sdl_update_caption(scon);
 }
 
@@ -773,6 +780,7 @@
         gui_noframe = 1;
     }
 
+#ifndef __ANDROID__
 #ifdef __linux__
     /* on Linux, SDL may use fbcon|directfb|svgalib when run without
      * accessible $DISPLAY to open X11 window.  This is often the case
@@ -785,6 +793,7 @@
      */
     setenv("SDL_VIDEODRIVER", "x11", 0);
 #endif
+#endif // __ANDROID__
 
     flags = SDL_INIT_VIDEO | SDL_INIT_NOPARACHUTE;
     if (SDL_Init(flags)) {
diff -ru --no-dereference ../qemu-2.11.0/ui/sdl2-2d.c ./ui/sdl2-2d.c
--- ../qemu-2.11.0/ui/sdl2-2d.c	2017-12-13 19:27:20.000000000 +0200
+++ ./ui/sdl2-2d.c	2017-12-25 11:28:14.951647500 +0200
@@ -66,7 +66,15 @@
 
     SDL_UpdateTexture(scon->texture, NULL, surface_data(surf),
                       surface_stride(surf));
+#if defined( __ANDROID__) && defined (__LIMBO_SDL_FORCE_HARDWARE_RENDERING__)
+    //Android OPENGL ES needs full screen redraw
+    SDL_SetRenderDrawColor( scon->real_renderer, 0, 0, 0, 255 );
+    SDL_RenderClear( scon->real_renderer );
+    SDL_RenderCopy(scon->real_renderer, scon->texture, NULL, NULL);
+#else
     SDL_RenderCopy(scon->real_renderer, scon->texture, &rect, &rect);
+#endif //__ANDROID_
+
     SDL_RenderPresent(scon->real_renderer);
 }
 
@@ -127,6 +135,11 @@
                                       surface_width(new_surface),
                                       surface_height(new_surface));
     sdl2_2d_redraw(scon);
+
+#ifdef __LIMBO__
+    //TODO: Need to send the resolution to Java
+    Android_JNI_SetSDLResolution(surface_width(new_surface), surface_height(new_surface));
+#endif //__ANDROID__
 }
 
 void sdl2_2d_refresh(DisplayChangeListener *dcl)
diff -ru --no-dereference ../qemu-2.11.0/ui/vnc.c ./ui/vnc.c
--- ../qemu-2.11.0/ui/vnc.c	2017-12-13 19:27:20.000000000 +0200
+++ ./ui/vnc.c	2017-12-25 11:28:14.951647500 +0200
@@ -47,7 +47,14 @@
 #include "io/dns-resolver.h"
 
 #define VNC_REFRESH_INTERVAL_BASE GUI_REFRESH_INTERVAL_DEFAULT
+
+//LIMBO: we can override the refresh rate for VNC here
+#ifdef __LIMBO__
+#define VNC_REFRESH_INTERVAL_INC  30
+#else
 #define VNC_REFRESH_INTERVAL_INC  50
+#endif //__LIMBO__
+
 #define VNC_REFRESH_INTERVAL_MAX  GUI_REFRESH_INTERVAL_IDLE
 static const struct timeval VNC_REFRESH_STATS = { 0, 500000 };
 static const struct timeval VNC_REFRESH_LOSSY = { 2, 0 };
diff -ru --no-dereference ../qemu-2.11.0/util/osdep.c ./util/osdep.c
--- ../qemu-2.11.0/util/osdep.c	2017-12-13 19:27:20.000000000 +0200
+++ ./util/osdep.c	2017-12-25 11:28:14.967273200 +0200
@@ -329,8 +329,18 @@
     }
 
 #ifdef O_CLOEXEC
+#ifdef __LIMBO__
+	if (strncmp(name, "/content/", 9) == 0) {
+		ret = android_openm(name, flags | O_CLOEXEC, mode);
+	} else
+#endif //__LIMBO__
     ret = open(name, flags | O_CLOEXEC, mode);
 #else
+#ifdef __LIMBO__
+	if (strncmp(name, "/content/", 9) == 0) {
+		ret = android_openm(name, flags, mode);
+	} else
+#endif //__LIMBO__
     ret = open(name, flags, mode);
     if (ret >= 0) {
         qemu_set_cloexec(ret);
@@ -356,7 +366,11 @@
     if (fdset_id != -1) {
         int ret;
 
+#ifdef __LIMBO__
+        ret = android_close(fd);
+#else
         ret = close(fd);
+#endif //__LIMBO__
         if (ret == 0) {
             monitor_fdset_dup_fd_remove(fd);
         }
@@ -364,7 +378,11 @@
         return ret;
     }
 
+#ifdef __LIMBO__
+	return android_close(fd);
+#else
     return close(fd);
+#endif //__LIMBO__
 }
 
 /*
diff -ru --no-dereference ../qemu-2.11.0/util/oslib-posix.c ./util/oslib-posix.c
--- ../qemu-2.11.0/util/oslib-posix.c	2017-12-13 19:27:20.000000000 +0200
+++ ./util/oslib-posix.c	2017-12-25 11:28:14.979643700 +0200
@@ -36,7 +36,10 @@
 #include "qapi/error.h"
 #include "qemu/sockets.h"
 #include <libgen.h>
+#if !defined(__ANDROID__) | defined(__ANDROID_HAS_SIGNAL__)
+//LIMBO: This is not needed for ANDROID 21 NDK and above
 #include <sys/signal.h>
+#endif //__ANDROID__
 #include "qemu/cutils.h"
 
 #ifdef CONFIG_LINUX
@@ -76,7 +79,9 @@
 
 int qemu_get_thread_id(void)
 {
-#if defined(__linux__)
+//Limbo: Not impl
+//#if defined(__linux__)
+#if defined(__linux__) & ( !defined(__ANDROID__) | defined(__ANDROID_HAS_SYS_GETTID__) )
     return syscall(SYS_gettid);
 #else
     return getpid();
diff -ru --no-dereference ../qemu-2.11.0/util/qemu-error.c ./util/qemu-error.c
--- ../qemu-2.11.0/util/qemu-error.c	2017-12-13 19:27:20.000000000 +0200
+++ ./util/qemu-error.c	2017-12-25 11:28:14.991008000 +0200
@@ -24,6 +24,7 @@
     REPORT_TYPE_INFO,
 } report_type;
 
+#if !defined (__LIMBO__)
 void error_printf(const char *fmt, ...)
 {
     va_list ap;
@@ -41,6 +42,7 @@
     error_vprintf_unless_qmp(fmt, ap);
     va_end(ap);
 }
+#endif //__ANDROID__
 
 static Location std_loc = {
     .kind = LOC_NONE
@@ -225,6 +227,7 @@
     error_printf("\n");
 }
 
+#ifndef __ANDROID__
 /*
  * Print an error message to current monitor if we have one, else to stderr.
  * Format arguments like vsprintf().  The resulting message should be
@@ -310,3 +313,4 @@
     vreport(REPORT_TYPE_INFO, fmt, ap);
     va_end(ap);
 }
+#endif //__ANDROID__
diff -ru --no-dereference ../qemu-2.11.0/util/qemu-openpty.c ./util/qemu-openpty.c
--- ../qemu-2.11.0/util/qemu-openpty.c	2017-12-13 19:27:20.000000000 +0200
+++ ./util/qemu-openpty.c	2017-12-25 11:28:14.998015700 +0200
@@ -110,16 +110,24 @@
 
 int qemu_openpty_raw(int *aslave, char *pty_name)
 {
+#ifndef __ANDROID__
     int amaster;
     struct termios tty;
+#endif //__ANDROID__
+
 #if defined(__OpenBSD__) || defined(__DragonFly__)
     char pty_buf[PATH_MAX];
 #define q_ptsname(x) pty_buf
+#elif defined(__ANDROID__)
+    //do nothing
 #else
     char *pty_buf = NULL;
 #define q_ptsname(x) ptsname(x)
 #endif
 
+#ifdef __ANDROID__
+    return -1;
+#else
     if (openpty(&amaster, aslave, pty_buf, NULL, NULL) < 0) {
         return -1;
     }
@@ -132,6 +140,6 @@
     if (pty_name) {
         strcpy(pty_name, q_ptsname(amaster));
     }
-
     return amaster;
+#endif //__ANDROID__
 }
diff -ru --no-dereference ../qemu-2.11.0/vl.c ./vl.c
--- ../qemu-2.11.0/vl.c	2017-12-13 19:27:20.000000000 +0200
+++ ./vl.c	2017-12-25 11:28:15.011025000 +0200
@@ -132,6 +132,10 @@
 #define MAX_VIRTIO_CONSOLES 1
 #define MAX_SCLP_CONSOLES 1
 
+#ifdef __LIMBO__
+char * limbo_base_dir;
+#endif
+
 static const char *data_dir[16];
 static int data_dir_idx;
 const char *bios_name = NULL;
@@ -4927,3 +4931,25 @@
 
     return 0;
 }
+
+#ifdef __LIMBO__
+
+void stop_vm(int no_reboot_vm) {
+    if (no_reboot_vm) {
+        shutdown_requested = 1;
+    } else {
+        reset_requested = 1;
+    }
+    cpu_stop_current();
+    qemu_notify_event();
+}
+int qemu_start(int argc, char **argv) {
+    return main(argc, argv, NULL);
+}
+
+int get_state(void) {
+    return runstate_is_running();
+}
+
+
+#endif //__LIMBO__
